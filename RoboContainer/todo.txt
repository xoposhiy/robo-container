+ Низкоуровневое конфигурирование — сканер, который может создать для каждого типа PluginConfiguration и PluggableConfiguration.
+ ScanAllLoadedAssemblies(Func<Assembly, bool> predicate)
+ Поддержка Lazy<T>
+ IEnumerable<T>, IList<T> и прочие должны резолвиться как массивы.
+ Экспорт частей. Если кому-то нужен I, а у одной из зарегистрированных частей такое свойство, помеченное спец-атрибутом, то можно взять I из этого свойства.

Документация

Именованные и дефолтные плагины. MissingPlugin

Расширяемый InstanceLifetime scope

Человечный Initialize

IDisposable

TryGet

Thread safety

Определять тип делегата CreateBy

BuildContext

Primitive arguments

container.AssertConfigurationIsValid();

registry

setter injection
field injection
method injection

target reguirements
public MyType([Tag("offline")]ISomeService service)


клевый интерфейс для получения generic-а если значения его параметров типа известны только в рантайме.
IGenericInterface gi = container.GetGeneric(typeof(IGeneric<,>), object1.GetType(), object2.GetType()).As<IGenericInterface>();
вместо:
IGenericInterface gi = (IGenericInterface)container.Get(typeof(IGeneric<,>).GetGenericTypeDefinition().MakeGeneric(object1.GetType(), object2.GetType());

IgnoreNamespace
IgnoreTypes

Если IA : IB и конфигурация для IB есть, а для IA нет, то при получении IA применяется конфигурация IB ?!? Подумать, правильно ли это.

Оптимизация создания PerRequest-ов.

Отладочная информация: по каким правилам разрешается заданный pluginType.

Оптимизация — построение всех вспомогательных структур данных на этапе конфигурирования.

Разделение этапов конфигурирования и использования. Даст возможность однажды сконфигурировав, быстро создавать чистенький контейнер. Разумно только с Оптимизацией.

