#summary Управляемое освобождение ресурсов контейнером.

Рассмотрим очень простую на первый взгляд идею: при вызове Dispose у контейнера, он мог бы вызывать Dispose у всех созданных им объектов (у всех, которые реализуют IDisposable, естественно). Удобно? Просто? Но, к сожалению не реально.
просто не существует. Ниже будут описаны проблемы, возникающие на этом пути, а в конце описано настоящее поведение `RoboContainer`.

===Долгоживущие объекты===
Контейнер действительно может заботится о вызове Dispose объектов с политикой повторного использования Reuse.Always. Однако даже тут можно попасть в засаду: может оказаться, что время жизни самого контейнера меньше, чем необходимое время жизни создаваемых им объектов. Например, так бывает, если контейнер используется лишь на старте программы для создания графа объектов, который далее длительное время будет выполнять свою работу.

===Короткоживущие объекты===
Если для некоторого сервиса контейнер на каждый запрос возвращает вновь созданный экземпляр, то управляемый контейнером вызов Dispose может стать довольно дорогим: контейнеру придется запоминать ссылки на все созданные им экземпляры, чтобы позже вызвать у них Dispose. Запоминать ссылки — значит мешать сборщику мусора делать свою работу.
Можно запоминать слабые ссылки, но тогда контейнер больше не может гарантировать того, что он обязательно вызовет Dispose у каждого созданного им объекта.

===Поведение !RoboContainer===

Решение, которое принято при проектировании `RoboContainer` следующее:
  # При вызове Dispose у контейнера, Dispose вызывается лишь у долгоживущих объектов, созданных контейнером.
  # Если Dispose у контейнера не был вызван, то Dispose у созданных контейнеров объектов также не вызывается. Тем самым вы можете взять управление освобождением ресурсов полностью на себя.
  # Dispose не вызывается у короткоживущих объектов. Поскольку контейнер не может понять, в какой момент времени короткоживущий объект перестает быть нужен, он не может вызвать Dispose вовремя. Поэтому вам придется сделать это самим.