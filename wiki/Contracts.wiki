#summary Контракты сервисов и реализаций

Обычно контейнеры предоставляют возможность дать разным реализациям одного сервиса разные имена. В `RoboContainer` используется обобщение механизма именованных реализаций — контракты.

Для начала нужно заметить, что вы всегда можете забыть про контракты и не использовать их вообще.

//TODO пример.

В самом простом варианте использования механизм контрактов полностью эквивалентен именованным реализациям. Так что если вы знакомы с другими контейнерами, то острой необходимости переучиваться у вас нет.

//TODO пример.

Однако, контракты позволяют более гибко настраивать работу контейнера. Ниже будет обстоятельно рассказано о том, что такое контракты, и что можно делать с их помощью.

==Метафора контракта==
Когда мы говорим о контракте, то мы имеем в виду два связанных с этим понятием действия:
  * Заказчик требует от своих исполнителей выполнения некоторых условий (требование контракта)
  * Исполнитель декларирует свои обязательства по исполнению некоторых условий (декларирование контракта).

Если исполнитель декларирует все условия, которые требуются заказчику, то они подходят друг-другу. Если исполнитель декларирует ещё какие-то условия — это ничему не мешает. Однако, если исполнитель не готов взять на себя некоторые пункты условий заказчика, то они друг другу определенно не подходят — заказчику придется искать другого исполнителя.

В случае с контейнером в роли исполнителя выступают конкретные реализации (pluggable) — они могут декларировать некоторые контракты. Заказчики же бывают разные:
  * Сервис (plugin) может потребовать выполнение некоторых контрактов и тогда автопоиск реализаций отбросит те реализации, которые не декларируют все требуемые контракты.
  * Некоторые зависимости класса могут требовать определенных контрактов. Контейнер подставит в эти зависимости лишь удовлетворяющие требованиям реализации.
  * Вы в своем коде при вызове одного из методов семейства Get можете явно указать требуемые контракты.

==Когда контракты не указаны==
Если реализация не декларирует явно ни одного контракта, то считается, что она декларирует один контракт "по-умолчанию".

Аналогично, если "заказчик" не требует ни одного контракта, считается, что он требует один контракт "по-умолчанию".

На первый взгляд может показаться, что это несколько нелогичное поведение. Чтобы понять, почему было сделано именно так, придется проблемный сценарий развития событий.

 Пусть у нас был сервис `IFoo` используемый в 100 местах нашей программы. Пусть у этого сервиса была только одна реализация `SimpleFoo`. Естественно в такой ситуации нет необходимости явно указывать контракты (и у реализации, и у сервиса).

 Пусть теперь вам вдруг понадобилось создать альтернативную реализацию `ComplexFoo : IFoo` и в некоторых случаях использовать именно ее. Чтобы различать эти две реализации, вы указываете у `ComplexFoo` контракт `is-complex` и ожидаете, что этого будет достаточно.

 Если бы отсутствие требований контрактов означало именно *отсутствие требований*, а не требование контракта "по-умолчанию", то вы бы оказались в проблемной ситуации, потому что во все предыдущие 100 мест использования `IFoo` теперь начало подходить уже не одна реализация, а целых две. Контейнер начал бы спотыкаться с ошибкой "найдено более одной реализации — не могу выбрать". Чтобы исправить ситуацию, вам пришлось бы задекларировать контракт и у `SimpleFoo`, скажем `is-simple`, а потом пройти по всей сотне мест использования и явно указать там требование контракта `is-simple`. Получается, что добавление одной новой реализации неминуемо приводит к каскадным правкам в предыдущем коде, что очень неприятно.

Очевидно, что с контрактами "по-умолчанию" подобной проблемы не будет.
Кроме того идея контрактов "по-умолчанию" на самом деле лучше соответствует бытовому пониманию. Действительно, если вы не предъявляете к своему исполнителю каких-то особенных требований, это вероятнее означает, что вы ожидаете от него каких то стандартных условий, а вовсе не означает, что вам абсолютно все равно что и как будет делать исполнитель.

Ниже приведен ряд примеров, демонстрирующих работу с контрактами:

//TODO