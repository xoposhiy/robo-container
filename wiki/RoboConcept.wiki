#summary Концепция проекта

= Основные принципы построения контейнера =

== Configurationless  ==
Контейнер должен быть готов к работе без конфигурирования вообще.
Если поведение несконфигурированного контейнера чем-то не устраивает, можно подправить его работу конфигурированием.

Например, если ваш проект состоит из нескольких сборок, то, возможно, вам придется сконфигурировать те сборки, где робоконтейнер будет искать необходимые ему типы. 

== Containerless code ==
Пользуясь контейнером должно быть возможно поддерживать рабочий код независимым от классов библиотеки контейнера. Всё конфигурирование должно быть возможно осуществлять внешним по отношению к коду образом. Без использования специальных атрибутов. Без наследования от специальных интерфейсов.

Все конфигурирование в этом случае проводится с помощью конструктора контейнера или с помощью метода `With` самого контейнера. В обоих случаях для конфигурирования нужно использовать делегат с одним параметром типа `IContainerConfigurator`:

<wiki:comment>[Configuration.FirstSample</wiki:comment>
{{{

var container = new Container(
	(IContainerConfigurator c) =>
		{
			c.ForPlugin<IPlugin>().UsePluggable<Pluggable>();
			c.ForPluggable<Pluggable>().ReuseIt(ReusePolicy.Never);
			c.ScanLoadedAssemblies(assembly => (assembly.FullName + "").Contains("RoboContainer"));
			c.Logging.Disable();
		});
}}}
<wiki:comment></wiki:comment>


== Local configuration ==
Должна быть возможность использовать и противоположный способ конфигурирования контейнера. Частично конфигурировать классы и интерфейсы прямо в коде, с помощью атрибутов и интерфейсов. Наиболее постоянные аспекты, связанные с классом удобно держать непостредственно рядом с определением класса.

Для этого нужно использовать атрибуты из пространства имен `RoboContainer.Infection`. Например, такие как
  * `ContainerConstructorAttribute`, чтобы определить который конструктор должен использоваться контейнером для создания типа.
  * `PluginAttribute`, для определения политики повторного использования плагина и прочего конфигурирования на уровне плагина.
  * `PlugggableAttribute`, для конфигурирования работы контейнера с данным типом в качестве реализации плагина.

== Ready out-of-the-box ==
Контейнер должен поддерживать базовые примитивы инжектирования, такие как ленивое инжектирование зависимостей, инжектирование коллекций, работа с generics.

== Tracebility ==
Поведение контейнера должно быть прозрачным. В любой момент должна быть возможность посмотреть как именно контейнер обрабатывал запрос, и почему он сделал это именно так.

Для этого в робоконтейнере есть встроенная подсистема логгирования, которую также можно сконфигурировать. Несконфигурированный контейнер запоминает лог последней сессии работы с контейнером и позволяет его просмотреть в качестве строки.

<wiki:comment>[Logging.ShowMeTheLog</wiki:comment>
{{{

var container = new Container();
var someObj = container.Get<SomeType>();
Console.WriteLine(container.LastConstructionLog);
}}}
<wiki:comment></wiki:comment>

== Fluent configuration interface ==
У контейнера должен быть очевидный, согласованный, простой интерфейс конфигурирования. Интерфейс должен минимизировать количество обращений к документации.

IContainerConfigurator и сопутствующие интерфейсы очень тщательно проработаны. Имена методов сделаны логичными и говорящими.