#summary Quick start

= Примеры использования !RoboContainer =

== 2 минутное введение в !RoboContainer==
Рассмотрим простой пример "Сборка робота".

<wiki:comment>[FirstSample</wiki:comment>
{{{

public interface IDistanceSensor
{
	// ...
}
public class OpticalSensor : IDistanceSensor
{
	// ...
}
public interface IRobot
{
	IDistanceSensor DistanceSensor { get; set; }
	// ...
}
public class Robot : IRobot
{
	public Robot(IDistanceSensor distanceSensor)
	{
		DistanceSensor = distanceSensor;
	}
	public IDistanceSensor DistanceSensor { get; set; }
	// ...
}
}}}
<wiki:comment></wiki:comment>

Тут контейнер самостоятельно догадывается о том, что в качестве `IRobot` нужно создать `Robot`, 
а для этого в конструктор класса `Robot` передать реализацию `IDistanceSensor`.

А для этого, в свою очередь, контейнер догадывается, что в качестве реализации `IDistanceSensor` 
нужно создать экземпляр класса `OpticalSensor`.

В этом примере контейнеру повезло — был всего один класс, реализующий интерфейс `IDistanceSensor` 
и только один, реализующий `IRobot`, поэтому контейнеру не составило труда догадаться, что нужно сделать.

Однако если у запрашиваемого интерфейса есть несколько реализаций, то контейнеру нужна подсказка:

<wiki:comment>[Weapons</wiki:comment>
{{{

public interface IMainWeapon
{
	// ...
}
public class RocketWeapon : IMainWeapon
{
	// ...

}
public class LaserWeapon : IMainWeapon
{
	// ...
}
[Test]
public void AssembleRobot()
{
	//[FirstSample
	var container = new Container();
	var robot = container.Get<IRobot>();
	Assert.IsInstanceOf<Robot>(robot);
	Assert.IsInstanceOf<OpticalSensor>(robot.DistanceSensor);

var container = new Container(c => c.ForPlugin<IMainWeapon>().PluggableIs<RocketWeapon>());
var weapon = container.Get<IMainWeapon>();
Assert.IsInstanceOf<RocketWeapon>(weapon);
}}}
<wiki:comment></wiki:comment>

По умолчанию при запросе одного интерфейса несколько раз, контейнер возвращает ссылки на один и тот же объект:

<wiki:comment>[SingletoneWeapon</wiki:comment>
{{{

var container = new Container(
	c => c.ForPlugin<IMainWeapon>().PluggableIs<RocketWeapon>()
	);
var weapon1 = container.Get<IMainWeapon>();
var weapon2 = container.Get<IMainWeapon>();
Assert.AreSame(weapon1, weapon2);
}}}
<wiki:comment></wiki:comment>

Такое поведение контейнера можно изменить с помощью дополнительного конфигурирования:

<wiki:comment>[TransientWeapon</wiki:comment>
{{{

var container = new Container(
	c => c.ForPlugin<IMainWeapon>().PluggableIs<RocketWeapon>()
	     	.SetScope(InstanceLifetime.PerRequest)
	);
var weapon1 = container.Get<IMainWeapon>();
var weapon2 = container.Get<IMainWeapon>();
Assert.AreNotSame(weapon1, weapon2); // NOT Same
}}}
<wiki:comment></wiki:comment>

Возможно ракетное оружие надо как-то по особому инициализировать перед началом использования. API конфигурирования позволяет сделать и это:

<wiki:comment>[PrepareRocketWeapon</wiki:comment>
{{{

var container = new Container(
	c =>
		{
			c.ForPlugin<IMainWeapon>().PluggableIs<RocketWeapon>();
			c.ForPluggable<RocketWeapon>().InitializeWith(
				rocketWeapon => rocketWeapon.LoadedMissile = "big rocket");
		}
	);
var weapon = (RocketWeapon) container.Get<IMainWeapon>();
Assert.AreEqual("big rocket", weapon.LoadedMissile);
}}}
<wiki:comment></wiki:comment>

API конфигурации позволяет и более хитро снаряжать роботов. 
В следующем примере контейнер создает по очереди ракетное и лазерное оружие.

<wiki:comment>[DifferentWeapons</wiki:comment>
{{{

var weaponIndex = 0;
var container = new Container(
	c => 
		c.ForPlugin<IMainWeapon>().SetScope(InstanceLifetime.PerRequest)
		.CreatePluggableBy(
	     	(aContainer, pluginType) =>
	     	weaponIndex++ % 2 == 0 ? (IMainWeapon) new LaserWeapon() : new RocketWeapon())
			);
Assert.IsInstanceOf<LaserWeapon>(container.Get<IMainWeapon>());
Assert.IsInstanceOf<RocketWeapon>(container.Get<IMainWeapon>());
Assert.IsInstanceOf<LaserWeapon>(container.Get<IMainWeapon>());
}}}
<wiki:comment></wiki:comment>

И под конец, важно ещё раз вспомнить 