#summary Конфигурирование контейнера

= Основные принципы конфигурирования =

Основная задача, которую приходится решать контейнеру — это определение того, какие объекты (pluggables) подходят для запрошенного типа (plugin). Влиять на это можно с помощью конфигурирования на двух уровнях: на уровне plugin и на уровне pluggable.

На каждом уровне конфигурирование можно производить с помощью атрибутов, а можно с помощью динамического конфигурирования с помощью параметра конструктора контейнера.

Естественно встает вопрос о том, как аспекты конфигурирования указанные на разных уровнях комбинируются друг с другом.

==Приоритеты==

Все аспекты конфигурирования делятся на дополныемые и перекрываемые в зависимости от того, как конфигурирование на разных уровнях влияют друг на друга. Дополняемые аспекты суммируются по всем видам конфигурирования, в то время как для перекрываемых аспектов используется результат конфигурирования на наиболее приоритетном уровне.

Ниже перечислены уровни конфигурирования в порядке возрастания приоритетности:

  * атрибуты pluggable _(низкий приоритет)_;
  * динамическое конфигурирование pluggable;
  * атрибуты plugin;
  * динамическое конфигурирование plugin _(высокий приоритет)_.

==Интерфейс динамического конфигурирования==

Динамическое конфигурирование осуществляется с помощью параметра конструктора контейнера.
<wiki:comment>[Configuration.FirstSample</wiki:comment>
{{{

var container = new Container(
	(IContainerConfigurator c) =>
		{
			c.ForPlugin<IPlugin>().UsePluggable<Pluggable>();
			c.ForPluggable<Pluggable>().ReuseIt(ReusePolicy.Never);
			c.ScanLoadedAssemblies(assembly => (assembly.FullName + "").Contains("RoboContainer"));
			c.Logging.Disable();
		});
}}}
<wiki:comment></wiki:comment>
Тут `c` — это объект, через который можно конфигурировать контейнер. В этом примере продемонстрировано:
  # настройка того, какие типы контейнер будет иметь в виду, а какие нет.
  # конфигурирование plugin'а.
  # конфигурирование pluggable/.
  
Полный список методов интерфейса представлен ниже:

<wiki:comment>[IContainerConfigurator.interface</wiki:comment>
{{{
void ScanAssemblies(Assembly[] assembliesToScan);
void ScanAssemblies(IEnumerable<Assembly> assembliesToScan);
void ScanCallingAssembly();
void ScanLoadedAssemblies();
void ScanLoadedAssemblies(Func<Assembly, Boolean> shouldScan);
void ScanTypesWith(ScannerDelegate scanner);
IPluggableConfigurator ForPluggable(Type pluggableType);
IPluggableConfigurator<TPluggable> ForPluggable<TPluggable>();
IPluginConfigurator<TPlugin> ForPlugin<TPlugin>();
IPluginConfigurator ForPlugin(Type pluginType);
ILoggingConfigurator Logging { get; }

}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне plugin==

TODO: пояснительный текст

<wiki:comment>[IGenericPluginConfigurator.interface</wiki:comment>
{{{
IPluginConfigurator<TPlugin> Ignore<TPluggable>();
IPluginConfigurator<TPlugin> Ignore(Type[] pluggableTypes);
IPluginConfigurator<TPlugin> UsePluggable<TPluggable>();
IPluginConfigurator<TPlugin> UsePluggable(Type pluggableType);
IPluginConfigurator<TPlugin> UseOnly(TPlugin part);
IPluginConfigurator<TPlugin> UseAlso(TPlugin part, ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> ReusePluggable(ReusePolicy reusePolicy);
IPluginConfigurator<TPlugin> ReusePluggable<TReuse>();
IPluginConfigurator<TPlugin> RequireContracts(ContractRequirement[] requiredContracts);
IPluginConfigurator<TPlugin> CreatePluggableBy(CreatePluggableDelegate<TPlugin> createPluggable);
IPluginConfigurator<TPlugin> InitializeWith(InitializePluggableDelegate<TPlugin> initializePluggable);
IPluginConfigurator<TPlugin> InitializeWith(Action<TPlugin> initializePlugin);

}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне pluggable==

TODO: пояснительный текст

<wiki:comment>[IGenericPluggableConfigurator.interface</wiki:comment>
{{{
IPluggableConfigurator<TPluggable> DeclareContracts(ContractDeclaration[] contractsDeclaration);
IPluggableConfigurator<TPluggable> ReuseIt(ReusePolicy reusePolicy);
IPluggableConfigurator<TPluggable> ReuseIt<TReuse>();
IPluggableConfigurator<TPluggable> Ignore();
IPluggableConfigurator<TPluggable> UseConstructor(Type[] argsTypes);
IPluggableConfigurator<TPluggable> InitializeWith(InitializePluggableDelegate<TPluggable> initializePluggable);
IPluggableConfigurator<TPluggable> InitializeWith(Action<TPluggable> initializePluggable);
IDependencyConfigurator Dependency(String dependencyName);

}}}
<wiki:comment></wiki:comment>

TODO: пояснительный текст

<wiki:comment>[IDependencyConfigurator.interface</wiki:comment>
{{{
IDependencyConfigurator RequireContract(String[] requiredContracts);
IDependencyConfigurator UseValue(Object o);
IDependencyConfigurator UsePluggable(Type pluggableType);
IDependencyConfigurator UsePluggable<TPluggable>();

}}}
<wiki:comment></wiki:comment>

