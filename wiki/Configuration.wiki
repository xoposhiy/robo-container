#summary Конфигурирование контейнера

= Основные принципы конфигурирования =

Основная задача, которую приходится решать контейнеру — это определение того, какие объекты (pluggables) подходят для запрошенного типа (plugin). 
Влиять на это можно с помощью конфигурирования на двух уровнях: на уровне plugin и на уровне pluggable.

На каждом уровне конфигурирование можно производить с помощью атрибутов, а можно с помощью динамического конфигурирования с помощью параметра конструктора контейнера.

Естественно встает вопрос о том, как аспекты конфигурирования указанные на разных уровнях комбинируются друг с другом.

==Приоритеты==

Все аспекты конфигурирования делятся на дополныемые и перекрываемые в зависимости от того, как конфигурирование на разных уровнях влияют друг на друга.
Дополняемые аспекты суммируются по всем видам конфигурирования, в то время как для перекрываемых аспектов используется результат конфигурирования 
на наиболее приоритетном уровне.

Ниже перечислены уровни конфигурирования в порядке возрастания приоритетности:

  * атрибуты pluggable _(низкий приоритет)_;
  * динамическое конфигурирование pluggable;
  * атрибуты plugin;
  * динамическое конфигурирование plugin _(высокий приоритет)_.

==Интерфейс динамического конфигурирования==

Динамическое конфигурирование осуществляется с помощью параметра конструктора контейнера.
<wiki:comment>[Configuration.FirstSample</wiki:comment>
{{{

var container = new Container(
	(IContainerConfigurator c) =>
		{
			c.ForPlugin<IPlugin>().UsePluggable<Pluggable>();
			c.ForPluggable<Pluggable>().ReuseIt(ReusePolicy.Never);
			c.ScanLoadedAssemblies(assembly => (assembly.FullName + "").Contains("RoboContainer"));
			c.Logging.Disable();
		});
}}}
<wiki:comment></wiki:comment>
В этом примере `c` — это объект специального интерфейса, через который можно конфигурировать контейнер. Что происходит в этом примере?

Сначала конфигурируется plugin. 
Следующей строкой конфигурируется pluggable. 
Затем типы, с которыми будет работать контейнер ограничиваются только сборками `RoboContainer`'а. И, наконец, отключается логгирование.
  
Полный список методов интерфейса представлен ниже:

<wiki:comment>[IContainerConfigurator.interface</wiki:comment>
{{{
void ScanAssemblies(Assembly[] assembliesToScan);
void ScanAssemblies(IEnumerable<Assembly> assembliesToScan);
void ScanCallingAssembly();
void ScanLoadedAssemblies();
void ScanLoadedAssemblies(Func<Assembly, Boolean> shouldScan);
void ScanTypesWith(ScannerDelegate scanner);
IPluggableConfigurator ForPluggable(Type pluggableType);
IPluggableConfigurator<TPluggable> ForPluggable<TPluggable>();
IPluginConfigurator<TPlugin> ForPlugin<TPlugin>();
IPluginConfigurator ForPlugin(Type pluginType);
ILoggingConfigurator Logging { get; }

}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне plugin==

Результат такого конфигурирования действует сразу на все pluggable, которые могут быть возвращены при запросе заданного plugin-а.
Такое конфигурирование можно произвести при помощи метода `IContainerConfigurator.ForPlugin`. Он возвращает следующий интерфейс:
<wiki:comment>[IGenericPluginConfigurator.interface</wiki:comment>
{{{
IPluginConfigurator<TPlugin> UsePluggable<TPluggable>(ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UsePluggable(Type pluggableType, ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UseInstance(TPlugin instance, ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UseInstanceCreatedBy(CreatePluggableDelegate<TPlugin> createPluggable);
IPluginConfigurator<TPlugin> UseOtherPluggablesToo();
IPluginConfigurator<TPlugin> DontUse<TPluggable>();
IPluginConfigurator<TPlugin> DontUse(Type[] pluggableTypes);
IPluginConfigurator<TPlugin> ReusePluggable(ReusePolicy reusePolicy);
IPluginConfigurator<TPlugin> ReusePluggable<TReuse>();
IPluginConfigurator<TPlugin> RequireContracts(ContractRequirement[] requiredContracts);
IPluginConfigurator<TPlugin> SetInitializer(InitializePluggableDelegate<TPlugin> initializePluggable);
IPluginConfigurator<TPlugin> SetInitializer(Action<TPlugin> initializePlugin);

}}}
<wiki:comment></wiki:comment>

<wiki:comment>[Configuration.Plugin</wiki:comment>
{{{

var explicitlySpecifiedPluggable = new Pluggable();
var container = new Container(
	c =>
	c.ForPlugin<IPlugin>()
		.UseInstance(explicitlySpecifiedPluggable)
		.UseOtherPluggablesToo()
		.ReusePluggable(ReusePolicy.Never)
	);
IEnumerable<IPlugin> pluggables = container.GetAll<IPlugin>();
CollectionAssert.Contains(pluggables, explicitlySpecifiedPluggable);
Assert.AreEqual(2, pluggables.Count());
}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне pluggable==

Для каждого конкретного типа, который мог бы выступать в роли pluggable, можно сконфигурировать то, как он будет создаваться, 
инициализироваться, какие для него будут определены контракты и нужно ли рассматривать этот тип при автоматическом поиске pluggable.

<wiki:comment>[IGenericPluggableConfigurator.interface</wiki:comment>
{{{
IPluggableConfigurator<TPluggable> DeclareContracts(ContractDeclaration[] contractsDeclaration);
IPluggableConfigurator<TPluggable> ReuseIt(ReusePolicy reusePolicy);
IPluggableConfigurator<TPluggable> ReuseIt<TReuse>();
IPluggableConfigurator<TPluggable> DontUseIt();
IPluggableConfigurator<TPluggable> UseConstructor(Type[] argsTypes);
IPluggableConfigurator<TPluggable> SetInitializer(InitializePluggableDelegate<TPluggable> initializePluggable);
IPluggableConfigurator<TPluggable> SetInitializer(Action<TPluggable> initializePluggable);
IDependencyConfigurator Dependency(String dependencyName);

}}}
<wiki:comment></wiki:comment>
TODO Sample

Кроме того, при конфигурировании pluggable, можно задать некотоую специфику о необходимых этому pluggable зависимостях.
Зависимости — это, например, параметры конструктора. Соответственно, имена зависимостей — это имена этих самых параметров.
Получить конфигуратор зависимости можно с помощью метода `IPluggableConfigurator.Dependency`. 
Интерфейс конфигуратора зависимостей выглядит так:

<wiki:comment>[IDependencyConfigurator.interface</wiki:comment>
{{{
IDependencyConfigurator RequireContract(String[] requiredContracts);
IDependencyConfigurator UseValue(Object o);
IDependencyConfigurator UsePluggable(Type pluggableType);
IDependencyConfigurator UsePluggable<TPluggable>();

}}}
<wiki:comment></wiki:comment>

С помощью этого конфигуратора можно явно указать, какое значение использовать для этой зависимости, либо какой pluggable, 
либо указать список требуемых контрактов, если вы решили положиться на автоматику.

TODO Sample