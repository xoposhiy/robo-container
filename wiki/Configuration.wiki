#summary Конфигурирование контейнера

= Основные принципы конфигурирования =

Основная задача, которую приходится решать контейнеру — это определение того, какие объекты (pluggables) подходят для запрошенного типа (plugin). 

Есть два независимых подхода к решению этой задачи:
  # Явное конфигурирование. В этом случае вы сами указываете какие типы или объекты нужно использовать в качестве pluggables для данного плагина.
  # Автоматика. В этом случае контенер сканирует доступные ему сборки на предмет тех типов, которые могли бы выступать в роли pluggables для запрошенного типа. В результате возвращаются объекты всех подошедших типов.

Эти два способа можно комбинировать: оставить работу автоматики, но дополнительно указать ещё несколько pluggables явно. Кроме того, работу автоматики также можно корректировать, явно запрещая использовать некоторые из типов в качестве реализации определенного плагина.

У контейнера есть ещё одна работа помимо выбора подходящих pluggables. Если у контейнера два раза запросили один и тот же plugin, то должен ли контейнер вернуть один и тот же объект или он должен создавать новый объект на каждый запрос? Это поведение можно выбрать самостоятельно, указав политику повторного использования для плагина или pluggable.


Итого, все конфигурирование можно разделить на конфигурирование на уровне плагина и на конфигурирование на уровне pluggable.

На каждом уровне конфигурирование можно производить с помощью атрибутов, а можно с помощью динамического конфигурирования с помощью параметра конструктора контейнера.

Естественно встает вопрос о том, как аспекты конфигурирования указанные на разных уровнях комбинируются друг с другом.

Все аспекты конфигурирования делятся по смыслу на дополныемые и перекрываемые.
Дополняемые аспекты суммируются по всем видам конфигурирования, в то время как для перекрываемых аспектов используется результат конфигурирования 
на наиболее приоритетном уровне.

Ниже перечислены уровни конфигурирования в порядке возрастания приоритетности:

  * атрибуты pluggable _(низкий приоритет)_;
  * динамическое конфигурирование pluggable;
  * атрибуты plugin;
  * динамическое конфигурирование plugin _(высокий приоритет)_.

==Интерфейс динамического конфигурирования==

Динамическое конфигурирование осуществляется с помощью параметра конструктора контейнера.
<wiki:comment>[Configuration.FirstSample</wiki:comment>
{{{

var container = new Container(
	(IContainerConfigurator c) =>
		{
			c.ForPlugin<IPlugin>().UsePluggable<Pluggable>();
			c.ForPluggable<Pluggable>().ReuseIt(ReusePolicy.Never);
			c.ScanLoadedAssemblies(assembly => (assembly.FullName + "").Contains("RoboContainer"));
			c.Logging.Disable();
		});
}}}
<wiki:comment></wiki:comment>
В этом примере `c` — это объект специального интерфейса, через который можно конфигурировать контейнер. Что происходит в этом примере?

Сначала конфигурируется plugin. 
Следующей строкой конфигурируется pluggable. 
Затем типы, с которыми будет работать контейнер ограничиваются только сборками `RoboContainer`'а. И, наконец, отключается логгирование.
  
Полный список методов интерфейса представлен ниже:

<wiki:comment>[IContainerConfigurator.interface</wiki:comment>
{{{
void ScanAssemblies(Assembly[] assembliesToScan);
void ScanAssemblies(IEnumerable<Assembly> assembliesToScan);
void ScanCallingAssembly();
void ScanLoadedAssemblies();
void ScanLoadedAssemblies(Func<Assembly, Boolean> shouldScan);
void ScanTypesWith(ScannerDelegate scanner);
IPluggableConfigurator ForPluggable(Type pluggableType);
IPluggableConfigurator<TPluggable> ForPluggable<TPluggable>();
IPluginConfigurator<TPlugin> ForPlugin<TPlugin>();
IPluginConfigurator ForPlugin(Type pluginType);
ILoggingConfigurator Logging { get; }

}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне plugin==

Результат такого конфигурирования действует сразу на все pluggable, которые могут быть возвращены при запросе заданного plugin-а.
Такое конфигурирование можно произвести при помощи метода `IContainerConfigurator.ForPlugin`. Он возвращает следующий интерфейс:
<wiki:comment>[IGenericPluginConfigurator.interface</wiki:comment>
{{{
IPluginConfigurator<TPlugin> UsePluggable<TPluggable>(ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UsePluggable(Type pluggableType, ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UseInstance(TPlugin instance, ContractDeclaration[] declaredContracts);
IPluginConfigurator<TPlugin> UseInstanceCreatedBy(CreatePluggableDelegate<TPlugin> createPluggable);
IPluginConfigurator<TPlugin> UseOtherPluggablesToo();
IPluginConfigurator<TPlugin> DontUse<TPluggable>();
IPluginConfigurator<TPlugin> DontUse(Type[] pluggableTypes);
IPluginConfigurator<TPlugin> ReusePluggable(ReusePolicy reusePolicy);
IPluginConfigurator<TPlugin> ReusePluggable<TReuse>();
IPluginConfigurator<TPlugin> RequireContracts(ContractRequirement[] requiredContracts);
IPluginConfigurator<TPlugin> SetInitializer(InitializePluggableDelegate<TPlugin> initializePluggable);
IPluginConfigurator<TPlugin> SetInitializer(Action<TPlugin> initializePlugin);

}}}
<wiki:comment></wiki:comment>

<wiki:comment>[Configuration.Plugin</wiki:comment>
{{{

var explicitlySpecifiedPluggable = new Pluggable();
var container = new Container(
	c =>
	c.ForPlugin<IPlugin>()
		.UseInstance(explicitlySpecifiedPluggable)
		.UseOtherPluggablesToo()
		.ReusePluggable(ReusePolicy.Never)
	);
IEnumerable<IPlugin> pluggables = container.GetAll<IPlugin>();
}}}
<wiki:comment></wiki:comment>

==Конфигурирование на уровне pluggable==

Для каждого конкретного типа, который мог бы выступать в роли pluggable, можно сконфигурировать то, как он будет создаваться, 
инициализироваться, какие для него будут определены контракты и нужно ли рассматривать этот тип при автоматическом поиске pluggable.

<wiki:comment>[IGenericPluggableConfigurator.interface</wiki:comment>
{{{
IPluggableConfigurator<TPluggable> DeclareContracts(ContractDeclaration[] contractsDeclaration);
IPluggableConfigurator<TPluggable> ReuseIt(ReusePolicy reusePolicy);
IPluggableConfigurator<TPluggable> ReuseIt<TReuse>();
IPluggableConfigurator<TPluggable> DontUseIt();
IPluggableConfigurator<TPluggable> UseConstructor(Type[] argsTypes);
IPluggableConfigurator<TPluggable> SetInitializer(InitializePluggableDelegate<TPluggable> initializePluggable);
IPluggableConfigurator<TPluggable> SetInitializer(Action<TPluggable> initializePluggable);
IDependencyConfigurator Dependency(String dependencyName);

}}}
<wiki:comment></wiki:comment>
TODO Sample

Кроме того, при конфигурировании pluggable, можно задать некотоую специфику о необходимых этому pluggable зависимостях.
Зависимости — это, например, параметры конструктора. Соответственно, имена зависимостей — это имена этих самых параметров.
Получить конфигуратор зависимости можно с помощью метода `IPluggableConfigurator.Dependency`. 
Интерфейс конфигуратора зависимостей выглядит так:

<wiki:comment>[IDependencyConfigurator.interface</wiki:comment>
{{{
IDependencyConfigurator RequireContract(String[] requiredContracts);
IDependencyConfigurator UseValue(Object o);
IDependencyConfigurator UsePluggable(Type pluggableType);
IDependencyConfigurator UsePluggable<TPluggable>();

}}}
<wiki:comment></wiki:comment>

С помощью этого конфигуратора можно явно указать, какое значение использовать для этой зависимости, либо какой pluggable, 
либо указать список требуемых контрактов, если вы решили положиться на автоматику.

TODO Sample