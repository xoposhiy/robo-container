#summary Xml-конфигурирование контейнера

= Xml-конфигурирование =

Xml-конфигурирование `RoboContainer` повторяет конфигурирование кодом.
Некоторые сложные аспекты (например инициализацию pluggable делегатом), невозможно сконфигурировать с помощью xml. Однако весь основной функционал конфигурирования доступен.


Рассмотрим для примера вот такой блок конфигурирования:
<wiki:comment>[XmlConfiguration.ConfigByCode</wiki:comment>
{{{

var container = new Container(
	c =>
	{
		c.ForPlugin<IComponent>()
			.UsePluggable<Component1>()
			.UsePluggablesAutosearch(true)
			.DontUse<Component2>()
			.DontUse<Component3>()
			.DontUse<Component4>()
			.ReusePluggable(ReusePolicy.Never);
		c.ForPluggable<Component1>().DontUseIt();
		c.ForPluggable<Component4>()
			.ReuseIt(ReusePolicy.Never)
			.UseConstructor(typeof(IComponent))
			.Dependency("comp").UsePluggable<Component2>();
	}
	);
}}}
<wiki:comment></wiki:comment>
Его можно переписать вот так:
<wiki:comment>[XmlConfiguration.ConfigByXmlFile</wiki:comment>
{{{

var container = new Container(c => c.ConfigureBy.XmlFile("Configuration\\ConfigSample.xml"));
}}}
<wiki:comment></wiki:comment>

Вот с таким config.xml:
<wiki:comment>[XmlConfiguration.Config.xml</wiki:comment>
{{{
<?xml version="1.0" encoding="utf-8" ?>
<robocontainer>
	
	<ForPlugin pluginType="RoboContainer.Tests.Configuration.IComponent, RoboContainer.Tests">
		<UsePluggable pluggableType="RoboContainer.Tests.Configuration.Component1, RoboContainer.Tests"/>
		<UsePluggablesAutosearch useAutosearch="true"/>
		<DontUse>
			<pluggableTypes item="RoboContainer.Tests.Configuration.Component2, RoboContainer.Tests"/>
			<pluggableTypes item="RoboContainer.Tests.Configuration.Component3, RoboContainer.Tests"/>
			<pluggableTypes item="RoboContainer.Tests.Configuration.Component4, RoboContainer.Tests"/>
		</DontUse>
		<ReusePluggable reusePolicy="Never"/>
	</ForPlugin>
	
	<ForPluggable pluggableType="RoboContainer.Tests.Configuration.Component1, RoboContainer.Tests">
		<DontUseIt/>
	</ForPluggable>
	
	<ForPluggable pluggableType="RoboContainer.Tests.Configuration.Component4, RoboContainer.Tests">
		<ReuseIt reusePolicy="Never"/>
		<UseConstructor>
			<argsTypes item="RoboContainer.Tests.Configuration.IComponent, RoboContainer.Tests"/>
		</UseConstructor>
		<Dependency dependencyName="comp">
			<UsePluggable pluggableType="RoboContainer.Tests.Configuration.Component2, RoboContainer.Tests"/>
		</Dependency>
	</ForPluggable>
	
</robocontainer>

}}}
<wiki:comment></wiki:comment>

По факту механизм конфигурирования с помощью xml полностью отделен от самого контейнера и просто конвертирует последовательность xml-элементов в последовательность вызовов методов переданного ему объекта (в случае с контейнером — это объект `IContainerConfigurator`). Поэтому интерфейс xml-конфигурирования гарантированно никогда не разойдется с интерфейсом конфигурирования кодом.

Кстати, механизм xml-конфигурирования вполне самостоятельная вещь и может использоваться не только применительно к контейнеру. Он довольно прост и, возможно, недостаточно гибок, но его всегда можно взять за основу. Код лежит в пространстве имен `RoboConfig` вот тут:
http://code.google.com/p/robo-container/source/browse/#svn/trunk/RoboContainer/RoboConfig